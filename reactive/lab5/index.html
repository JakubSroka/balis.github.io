<HTML>
<HEAD>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<TITLE>Scala</TITLE>
<link rel="stylesheet" type="text/css" href="../style.css">
</HEAD>
<BODY>
<TABLE WIDTH="80%" HEIGHT="90%" BORDER="0" ALIGN=CENTER>
<TR>
<TD ALIGN=CENTER>
<DIV ALIGN=left>

<hr>
    <H2>Programowanie reaktywne w języku Scala</H2>
<hr>

<h3>Persystencja aktorów</h3>

<ul>
<li>W celu zapisywania stanu aktora, używamy wzorca <TT>Event Sourcing</TT> Zaimplementowanego w bibliotece <a href="http://doc.akka.io/docs/akka/2.3.6/scala/persistence.html">
Akka persistence</a>.
<li> Przykładowy <a href=reactive-persistence.zip>projekt</a> używający persystencji Akki</li>
<li>Projekt można wykonać przy pomocy komendy <TT>sbt run</TT>. Można też z niego wygenerować projekt w eclipse: <TT>sbt eclipse</TT>. 
<li>Proszę sprawdzić zachowanie aktora przy kilkukrotnym uruchomieniu projektu. Co się zmienia, gdy wyślemy do niego komunikat <TT>Snap</TT>?
<li>Projekt wykorzystuje wbudowaną bazę danych LevelDB do zapisu dziennka zdarzeń. Pliki bazy tworzone są w katalogu <TT>journal/</TT>. 
<li>Baza używa wbudowanej implementacji w Javie, co skonfigurowane jest w pliku <a href="https://github.com/balis/balis.github.io/blob/master/reactive/lab5/reactive-persistence/src/main/resources/application.conf"><TT>src/main/resources/application.conf</TT></a>.


</ul>

<H3>Zadanie</H3>
<OL>
    <LI>(20 pkt) Proszę dodać do systemu aukcyjnego aktora <B>MasterSearch</B> 
    <UL>
        <LI><B>MasterSearch</B> zarządza wieloma aktorami <B>AuctionSearch</B> poprzez mechanizm routingu
        <li> Aktorzy <B> Seller </B> rejestrują aukcje poprzez <B>MasterSearch</B></li>
        <li>Aktorzy <B>Buyer</B> dokonują zapytań wyszukiwania również poprzez <B>MasterSearch</B></li>
        <li>(<B>Wariant z partycjonowaniem</B>) Zaimplementować wariant, w którym rejestracja aukcji odbywa sie u jednego aktora <B>AuctionSearch</B>
            poprzez logikę routera <I>RoundRobinRoutingLogic</I>, a wyszukiwanie odbywa się u wszystkich 
            aktorów <B>AuctionSearch</B> (logika <I>BroadcastRoutingLogic</I>).
        </li>
        <li>(<B>Wariant z replikacją</B>) Zaimplementować wariant, w którym rejestracja aukcji odbywa sie u wszystkich aktorów <B>AuctionSearch</B>
            poprzez logikę routera <I>BroadcastRoutingLogic</I> (redundacja danych), a wyszukiwanie u jednego aktora 
             <B>AuctionSearch</B> (logika <I>RoundRobinRoutingLogic</I>).
        </li>
    </UL>
    <P>
    <LI>(10 pkt) Wykonać testy wydajnościowe obydwu przypadków. Jak długo trwa pojedyncze wyszukiwanie
    w zależności od liczby zarejestrowanych aukcji oraz obciążenia systemu zapytaniami wyszukiwania?  
    Jak długo trwa pojedyncze wyszukiwanie w zależności od różnej ilości aktorów <I>AuctionSearch</I>? 
    Jaki jest średni czas odpowiedzi? W jakim czasie mieści się 75%, 90% zapytań? Wyniki przedstawić na wykresach.
    <P>
    <LI>(10 pkt) Do dynamicznego skalowania Akka udostępnia mechanizm <a href="http://doc.akka.io/docs/akka/snapshot/scala/routing.html#Dynamically_Resizable_Pool"> Dynamically Resizable Pool</a>,
    gdzie używa domyślnego
    <a href=http://alvinalexander.com/java/jwarehouse/akka-2.3/akka-actor/src/main/scala/akka/routing/Resizer.scala.shtml> resizera</a>.
    Proszę dodać ten mechanizm do wersji z replikacją danych i zbadać jego wpływ na działanie systemu. 
    <UL>

    </UL>
</OL>
<!--
<H3>Bibliografia</H3>
<OL>
</OL>
!-->
<P>
<P>
<HR>
<I>Bartosz Baliś, balis at agh edu pl</I>
<BR>
<I>Maciej Malawski, malawski at agh edu pl</I>
<BR>
<I>Katarzyna Rycerz, kzajac at agh edu pl</I>
<BR>
<P> <P>
</DIV>
</TR>
</TD>
</TABLE>
</BODY>
</HTML>
